# =Piped a fast minimal file parser designed to operated against well delimited text files.


class PipeDelimited
  # Set the default options.
  # Defaults to:
  # * :field_delimiter = "<COL>"
  # * :row_delimiter   = "<EOL>"
  # * :trim_spaces     = true
  # * :column_case     = :lower, valid options are (:lower, :upper, :retain)    
  def initialize(input_file, options = {})
    @input_file = input_file
    @line_number = nil
    @header_cols = []
    @current_line = nil
    @line_number = nil
    @file_opened = false
    
    # Merge in default options
    @options = {
      :row_delimiter    => "<EOL>",
      :field_delimiter  => "<COL>",
      :trim_spaces      => true,
      :column_case      => :lower
    }.merge(options)
    
    @field_delimiter = @options[:field_delimiter]
    @row_delimiter = @options[:row_delimiter]
  end
  
  attr_accessor :header_cols, :current_line, :line_number
  
  # Open the file and mark the file_opened flag.
  def open_file(file_name = @input_file)
    @fh = open(file_name)
    @file_opened = true
  end
  
  # Each iterator will return each *data* row in the file as a hash.
  # Each column will be stored under it's related column name.
  # If you want to get the header columns, call the header_cols attribute
  def each()
    
    output = ''
    
    while output != nil
      begin
        output = next_line
        yield output
      rescue EOFError
        # end of file reached
        output = nil
      end
    end
    
  end
  
  # Similar to each, but yields the line_number as the second parameter.
  # The header row is considered line 0.
  def each_with_index()
    each do |line|
      yield line, @line_number
    end
  end
  
  # Returns each subsequent line in the file until the EOF is reached.
  def next_line
    open_file(@input_file) if !@file_opened
    
    @current_line = @fh.readline(@row_delimiter)
    
    if @line_number == nil
      @line_number = 0
      @header_cols = parse_header(@current_line)
      return next_line
    else
      @line_number += 1
      return parse_line(current_line)
    end
  
  end
  
  # parses each data line of the file and returns a hash with items properly mapped to the header column
  def parse_line(line)
    output_hash = {}
    
    # Passing -1 to split allows it to return trailing null fields
    split_line = line.gsub(@row_delimiter, '').split(@field_delimiter, -1)
    
    # Trim out extraneous spaces
    if @options[:trim_spaces]
      split_line.collect! {|el| el.strip}
    end
    
    # loop through each line of the file and assign ech column to a hash 
    # based on the ordinal position of the header column
    split_line.each_with_index do |element, index|
      output_hash[@header_cols[index]] = element
    end
    
    output_hash
  end
  
  #parses the header line into an Array of columns
  def parse_header(header_line)
    
    header_line.gsub(@row_delimiter, '').split(@field_delimiter).collect {|item|
      case @options[:column_case]
      when :lower
        item.downcase
      when :upper
        item.upcase
      else
        item
      end
    }
  end
  
  
end